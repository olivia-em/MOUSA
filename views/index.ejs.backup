<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÎœÎ¿á¿¦ÏƒÎ±</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <div class="minimal-container">
      <!-- Translation display - centered -->
      <div id="translationDisplay" class="translation-display hidden">
        <div id="textContent" class="text-content english"></div>
      </div>

      <!-- Fixed floating button - bottom right -->
      <button id="cycleBtn" class="floating-btn">
        <span class="btn-text">â–¶</span>
      </button>
    </div>

    <script>
      class TranslationCycle {
        constructor() {
          this.currentCycle = 0;
          this.currentText = "";
          this.originalGreek = "";
          this.isLoading = false;
          this.isRunning = false;
          this.shouldStop = false;
          this.audioFinished = false;
          this.cycleLog = [];
          this.currentUtterance = null; // Track current audio for crossfade

          this.ttsSettings = {
            rate: 0.6,
            pitch: 0.8,
            volume: 1.0,
            lang: "el-GR",
          };

          this.init();
        }
        async init() {
          await this.loadOriginalText();
          this.setupEventListeners();
          this.enableButton();
        }

        async loadOriginalText() {
          try {
            const response = await fetch("/api/passages/odyssey_book1");
            const data = await response.json();

            if (data.error) {
              throw new Error(data.error);
            }

            this.originalGreek = data.content;
            this.currentText = this.originalGreek;
          } catch (error) {
            console.error("Failed to load original text:", error);
            this.showError("Failed to load text");
          }
        }

        setupEventListeners() {
          const btn = document.getElementById("cycleBtn");
          btn.addEventListener("click", () => this.handleToggleClick());

          // Keyboard shortcut to download log (Ctrl/Cmd + L)
          document.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "l") {
              e.preventDefault();
              this.downloadLog();
              console.log("Translation log downloaded");
            }
          });
        }

        enableButton() {
          const btn = document.getElementById("cycleBtn");
          btn.disabled = false;
          btn.classList.remove("loading");
        }

        async handleToggleClick() {
          if (this.isRunning) {
            // Stop the continuous cycle
            this.stopCycle();
          } else {
            // Start the continuous cycle
            this.startCycle();
          }
        }

        startCycle() {
          this.isRunning = true;
          this.shouldStop = false;
          this.updateButtonState();
          this.runContinuousCycle();
        }

        stopCycle() {
          this.shouldStop = true;
          this.isRunning = false;
          this.updateButtonState();

          // Stop any current audio when manually stopping
          if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
          }
        }

        updateButtonState() {
          const btn = document.getElementById("cycleBtn");
          if (this.isRunning) {
            btn.querySelector(".btn-text").textContent = "â¸";
            btn.classList.add("running");
          } else {
            btn.querySelector(".btn-text").textContent = "â–¶";
            btn.classList.remove("running");
          }
        }

        async runContinuousCycle() {
          while (this.isRunning && !this.shouldStop) {
            try {
              // Increment cycle number at the start so it matches the log
              this.currentCycle++;
              console.log(`Starting cycle ${this.currentCycle}`);

              if (this.currentCycle === 1) {
                // First cycle: Greek â†’ English
                await this.firstCycle();
              } else {
                // Subsequent cycles: English â†’ Greek â†’ English
                await this.subsequentCycle();
              }

              // No pause needed - continuous flow
            } catch (error) {
              console.error("Cycle failed:", error);
              this.logCycle(
                "ERROR",
                `Cycle ${this.currentCycle} failed: ${error.message}`,
                this.currentCycle
              );
              this.showError("Translation failed");
              this.stopCycle();
              break;
            }
          }
          console.log("Continuous cycle stopped");
        }

        async firstCycle() {
          console.log("ðŸ“¡ Making API call for firstCycle...");

          // Translate Greek to English first
          const response = await fetch("/api/single-translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              text: this.originalGreek,
              is_greek: true,
            }),
          });

          console.log("ðŸ“¡ API response status:", response.status);

          const result = await response.json();
          console.log("ðŸ“¡ API result:", result);

          if (result.error) {
            console.error("âŒ API error:", result.error);
            throw new Error(result.error);
          }

          // Store the translation and prepare for synchronized display
          this.currentText = result.translation;
          // currentCycle is already set in runContinuousCycle

          console.log("ðŸ“¡ Translation successful, calling playWithFadeIn...");

          // Start audio and word fade-in simultaneously
          await this.playWithFadeIn(this.originalGreek, this.currentText);
        }

        async subsequentCycle() {
          // Current text is English, translate to Greek first
          const toGreekResponse = await fetch("/api/single-translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              text: this.currentText,
              is_greek: false,
            }),
          });

          const greekResult = await toGreekResponse.json();
          if (greekResult.error) throw new Error(greekResult.error);

          // Translate back to English
          const toEnglishResponse = await fetch("/api/single-translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              text: greekResult.translation,
              is_greek: true,
            }),
          });

          const englishResult = await toEnglishResponse.json();
          if (englishResult.error) throw new Error(englishResult.error);

          // Store the translation and prepare for synchronized display
          this.currentText = englishResult.translation;
          // currentCycle is already incremented in runContinuousCycle

          // Start audio and word fade-in simultaneously
          await this.playWithFadeIn(greekResult.translation, this.currentText);
        }

        async playWithFadeIn(greekText, englishText) {
          // Check if we should stop before starting audio/animation
          if (this.shouldStop) return;

          // Log this cycle
          this.logCycle(greekText, englishText, this.currentCycle);

          // Prepare the display element
          const display = document.getElementById("translationDisplay");
          const content = document.getElementById("textContent");

          // Reset any existing transition first
          content.style.transition = "none";
          content.style.opacity = "0";

          // Set up the text content
          content.textContent = englishText;
          display.classList.remove("hidden");

          // Force a reflow to ensure the reset is applied
          content.offsetHeight;

          // Start the Greek audio - let it play to completion (no cutting)
          this.playGreekAudio(greekText);

          // Fade in the entire English text slowly
          setTimeout(() => {
            if (!this.shouldStop) {
              content.style.transition = "opacity 2s ease-in";
              content.style.opacity = "1";
            }
          }, 100);

          // First cycle is 5 seconds, subsequent cycles are 10 seconds
          const cycleDelay = this.currentCycle === 1 ? 5000 : 10000;
          await this.delay(cycleDelay);

          console.log(`${cycleDelay / 1000}-second cycle completed for cycle ${this.currentCycle}`);
        }

        playGreekAudio(greekText) {
          console.log(
            "Starting Greek audio:",
            greekText.substring(0, 50) + "..."
          );

          if (!window.speechSynthesis) {
            console.warn("TTS not supported");
            return;
          }

          const utterance = new SpeechSynthesisUtterance(greekText);
          utterance.lang = "el-GR";
          utterance.rate = 0.6;
          utterance.pitch = 0.8;
          utterance.volume = 1.0;

          // Store the cycle number when audio starts to avoid mislabeling
          const audioCycleNumber = this.currentCycle;

          utterance.onstart = () => {
            console.log(
              "âœ… Greek audio started (cycle",
              audioCycleNumber,
              ")"
            );
          };

          utterance.onend = () => {
            console.log(
              "âœ… Greek audio finished (cycle",
              audioCycleNumber,
              ")"
            );
          };

          utterance.onerror = (event) => {
            console.error("âŒ Greek audio error:", event);
          };

          window.speechSynthesis.speak(utterance);
        }

        fadeOutCurrentAudio() {
          if (!this.currentUtterance) return;

          console.log("Starting audio fade out...");

          // Quick fade out over 500ms
          const fadeSteps = 10;
          const fadeInterval = 50; // 50ms per step = 500ms total
          const volumeStep = this.ttsSettings.volume / fadeSteps;
          let currentVolume = this.ttsSettings.volume;

          const fadeTimer = setInterval(() => {
            currentVolume -= volumeStep;

            if (currentVolume <= 0) {
              // Fade complete - cancel audio
              window.speechSynthesis.cancel();
              clearInterval(fadeTimer);
              console.log("Audio fade out complete");
              this.currentUtterance = null;
            } else {
              // Continue fading (note: this might not work perfectly with SpeechSynthesis)
              if (this.currentUtterance) {
                this.currentUtterance.volume = Math.max(0, currentVolume);
              }
            }
          }, fadeInterval);
        }

        displayResult(text) {
          const display = document.getElementById("translationDisplay");
          const content = document.getElementById("textContent");

          content.textContent = text;
          content.style.opacity = "1";
          content.style.transition = "none";
          display.classList.remove("hidden");
        }

        estimateAudioDuration(text) {
          // More accurate estimation based on character count and TTS settings
          // Average Greek characters per second at rate 0.6: ~8-10 chars/sec
          const chars = text.length;
          const charsPerSecond = 8; // Conservative estimate for Greek
          const baseDurationMs = (chars / charsPerSecond) * 1000;

          // Account for the slower TTS rate (0.6)
          const adjustedDuration = baseDurationMs / this.ttsSettings.rate;

          return Math.max(3000, Math.min(adjustedDuration, 15000)); // Between 3-15 seconds
        }

        showLoading() {
          const btn = document.getElementById("cycleBtn");
          btn.classList.add("loading");
          btn.querySelector(".btn-text").textContent = "â³";
        }

        hideLoading() {
          const btn = document.getElementById("cycleBtn");
          btn.classList.remove("loading");
          btn.querySelector(".btn-text").textContent = "â–¶";
        }

        showError(message) {
          const display = document.getElementById("translationDisplay");
          const content = document.getElementById("textContent");

          content.textContent = message;
          content.className = "text-content error";
          display.classList.remove("hidden");
        }

        delay(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }

        logCycle(greekText, englishText, cycleNumber) {
          const logEntry = {
            cycle: cycleNumber,
            timestamp: new Date().toISOString(),
            greek: greekText, // Full Greek text now
            english: englishText,
            greekLength: greekText.length,
            englishLength: englishText.length,
            englishWordCount: englishText.split(/\s+/).length,
          };

          this.cycleLog.push(logEntry);
          console.log(`=== CYCLE ${cycleNumber} LOG ===`);
          console.log(
            `English (${logEntry.englishWordCount} words, ${logEntry.englishLength} chars):`,
            englishText
          );
          console.log(
            `Greek (${logEntry.greekLength} chars):`,
            greekText.substring(0, 100) + (greekText.length > 100 ? "..." : "")
          );

          // Save to localStorage as backup
          localStorage.setItem(
            "museTranslationLog",
            JSON.stringify(this.cycleLog)
          );
        }

        downloadLog() {
          const dataStr = JSON.stringify(this.cycleLog, null, 2);
          const dataBlob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `muse_translation_log_${
            new Date().toISOString().split("T")[0]
          }.json`;
          link.click();
          URL.revokeObjectURL(url);
        }
      }

      // Initialize when page loads
      window.addEventListener("DOMContentLoaded", () => {
        new TranslationCycle();
      });
    </script>
  </body>
</html>
